"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.gradient = exports.staticRef = exports.namedAlias = exports.alias = void 0;
var getGradientPointsFromColor_1 = require("./getGradientPointsFromColor");
function readThemeToken(theme, token) {
    var _a, _b;
    return (_a = theme[token]) !== null && _a !== void 0 ? _a : ((_b = theme['colors']) !== null && _b !== void 0 ? _b : {})[token];
}
/**
 * Функция выполняет подстановку значения другого токена.
 * @param token Имя токена. Можно использовать токены из текущей темы либо из всех тем,
 * от которой наследуется текущая.
 */
function alias(token) {
    return function (theme) { return readThemeToken(theme, token); };
}
exports.alias = alias;
/**
 * Функция создаёт runtime-ссылку на другой токен темы выполняет подстановку fallback-значения этого токена.
 * @param token Имя токена. Можно использовать токены из текущей темы либо из всех тем,
 * от которой наследуется текущая.
 */
function namedAlias(token) {
    return function (theme) { return [token, readThemeToken(theme, token)]; };
}
exports.namedAlias = namedAlias;
/**
 * Функция создаёт runtime-ссылку на другой токен темы.
 * @param token Имя токена. Можно использовать любые токены, которые находятся в контексте страницы.
 */
function staticRef(value) {
    if (typeof value === 'function') {
        throw new Error('Cannot use callable token value in static ref');
    }
    return value;
}
exports.staticRef = staticRef;
function makeOpacityPoints(count) {
    var result = [];
    for (var i = 0; i < count; i++) {
        var percent = Math.round(i * (1 / (count - 1)) * 100);
        result.push([1, percent]);
    }
    return result;
}
function gradient() {
    var stops = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        stops[_i] = arguments[_i];
    }
    var opacityPoints = stops.length > 1 ? makeOpacityPoints(stops.length) : getGradientPointsFromColor_1.defaultOpacityPoints;
    return function (theme) {
        return opacityPoints
            .map(function (_a, index) {
            var _b;
            var pointOpacity = _a[0], pointCoordinate = _a[1];
            var stop = (_b = stops[index]) !== null && _b !== void 0 ? _b : stops[stops.length - 1];
            var _c = typeof stop === 'function' ? stop(theme) : [undefined, stop], stopKey = _c[0], stopValue = _c[1];
            var pointRaw = (0, getGradientPointsFromColor_1.makeGradientPointRaw)(stopValue, 
            // Привязываем к переменной только стопы с оригинальной прозрачностью
            pointOpacity === 1 ? stopKey : undefined);
            return (0, getGradientPointsFromColor_1.getGradientPointsFromColor)(pointRaw, 1, [[pointOpacity, pointCoordinate]]);
        })
            .join(', ');
    };
}
exports.gradient = gradient;
