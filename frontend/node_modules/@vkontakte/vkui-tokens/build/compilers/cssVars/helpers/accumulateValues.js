"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.accumulateValues = void 0;
var tools_1 = require("../../../../interfaces/general/tools");
var passOriginalValue = function (_a) {
    var toValue = _a.toValue, fromValue = _a.fromValue;
    if (typeof toValue === 'object' && 'name' in toValue && typeof toValue.name === 'string') {
        toValue.originalValue = fromValue.originalValue;
        return;
    }
    Object.keys(toValue).forEach(function (key) {
        passOriginalValue({
            toValue: toValue[key],
            fromValue: fromValue[key],
        });
    });
};
var constructSourceVal = function (_a) {
    var destination = _a.destination, value = _a.value, autoValue = _a.autoValue, singleBreakpoint = _a.singleBreakpoint;
    if (autoValue && 'name' in autoValue) {
        destination[autoValue.name] = !singleBreakpoint
            ? "var(".concat(value.name, ")")
            : value.originalValue;
    }
    else if (value.originalValue !== undefined) {
        destination[value.name] = value.originalValue;
    }
};
var fillValues = function (_a) {
    var destination = _a.destination, value = _a.value, adaptiveDestination = _a.adaptiveDestination, autoValue = _a.autoValue, manyAdaptiveStates = _a.manyAdaptiveStates;
    if (typeof value === 'object' && 'name' in value && typeof value.name === 'string') {
        constructSourceVal({
            destination: destination,
            value: value,
            autoValue: autoValue,
            singleBreakpoint: !manyAdaptiveStates,
        });
        return;
    }
    Object.entries(value).forEach(function (_a) {
        var key = _a[0], valProp = _a[1];
        var val = valProp;
        if (tools_1.adaptiveKeys.includes(key)) {
            if (!adaptiveDestination[key]) {
                adaptiveDestination[key] = {};
            }
            fillValues({
                destination: adaptiveDestination[key],
                value: val,
                autoValue: value.auto,
                manyAdaptiveStates: Object.keys(value).length > 2,
            });
        }
        if (key === 'auto') {
            var manyAdaptiveStates_1 = Object.keys(value).length > 2;
            if (!manyAdaptiveStates_1) {
                passOriginalValue({
                    toValue: val,
                    fromValue: value['regular'],
                });
            }
            fillValues({
                destination: adaptiveDestination.auto,
                value: value['regular'],
                autoValue: val,
                manyAdaptiveStates: manyAdaptiveStates_1,
            });
        }
        fillValues({
            destination: destination,
            value: val,
            autoValue: autoValue === null || autoValue === void 0 ? void 0 : autoValue[key],
            manyAdaptiveStates: manyAdaptiveStates,
        });
    });
};
function accumulateValues(_a) {
    var theme = _a.theme;
    var flatValues = {};
    var adaptiveValues = {
        auto: {},
        regular: {},
    };
    Object.keys(theme).forEach(function (key) {
        var value = theme[key];
        if (key === 'breakpoints' || key === 'themeType') {
            return;
        }
        fillValues({
            destination: flatValues,
            value: value,
            adaptiveDestination: adaptiveValues,
            manyAdaptiveStates: false,
        });
    });
    return { flatValues: flatValues, adaptiveValues: adaptiveValues };
}
exports.accumulateValues = accumulateValues;
