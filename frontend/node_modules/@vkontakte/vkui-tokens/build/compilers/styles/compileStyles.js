"use strict";
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compileStyles = exports.getRootSelector = exports.getPrefix = exports.serviceKeys = void 0;
require("css.escape");
var node_assert_1 = require("node:assert");
var common_tags_1 = require("common-tags");
var getAllButColors_1 = require("../../helpers/getAllButColors");
var getAllButSizes_1 = require("../../helpers/getAllButSizes");
var getOnlyColors_1 = require("../../helpers/getOnlyColors");
var unCamelcasify_1 = require("../../helpers/unCamelcasify");
var tokenProcessors_1 = require("./helpers/tokenProcessors");
var tokenRecognition_1 = require("./helpers/tokenRecognition");
exports.serviceKeys = ['breakpoints', 'prefix', 'themeType'];
function isClassicCssType(format) {
    return format === tokenProcessors_1.EStyleTypes.CSS || format === tokenProcessors_1.EStyleTypes.PCSS;
}
function getPrefix(format, theme) {
    var prefix = theme.prefix ? "".concat(theme.prefix, "-") : '';
    if (isClassicCssType(format) && prefix) {
        prefix += '-';
    }
    if (format === tokenProcessors_1.EStyleTypes.CSS && !prefix) {
        prefix = 'vkui--';
    }
    return prefix;
}
exports.getPrefix = getPrefix;
function isOnlyVariables(mode) {
    return mode.toLowerCase().includes('onlyvariables');
}
function isLocal(mode) {
    return mode.toLowerCase().includes('local');
}
function isIncremental(mode) {
    return mode.toLowerCase().includes('incremental');
}
function getThemeNameBase(theme) {
    var _a;
    return (_a = theme.themeNameBase) !== null && _a !== void 0 ? _a : theme.themeName;
}
function getRootSelector(theme, mode) {
    if (!isLocal(mode)) {
        return ':root';
    }
    return ".".concat(getPrefix(tokenProcessors_1.EStyleTypes.CSS, theme)).concat(getThemeNameBase(theme), "--").concat(theme.colorsScheme);
}
exports.getRootSelector = getRootSelector;
function isDeepEqual(actual, expected) {
    try {
        (0, node_assert_1.deepStrictEqual)(actual, expected);
        return true;
    }
    catch (_) {
        return false;
    }
}
/**
 * Компилирует строку со стилями (в разных форматах), на основе темы
 */
var compileStyles = function (format, theme, mode, themeBase) {
    if (mode === void 0) { mode = 'default'; }
    var classicCssType = isClassicCssType(format);
    var prefix = getPrefix(format, theme);
    var rootSelector = getRootSelector(theme, mode);
    var incremental = isIncremental(mode);
    var getDeclaration = tokenProcessors_1.varDeclarations[format];
    var getVariableStatement = tokenProcessors_1.variablesStatementDeclaration[format];
    var getCustomMediaDeclaration = tokenProcessors_1.customMediaDeclaration[format];
    var result = '';
    var variables = '';
    var groupTokens = '';
    switch (mode) {
        case 'onlyColors':
            theme = (0, getOnlyColors_1.getOnlyColors)(theme);
            break;
        case 'noSizes':
            theme = (0, getAllButSizes_1.getAllButSizes)(theme, theme.themeNameBase);
            break;
        case 'noColors':
            theme = (0, getAllButColors_1.getAllButColors)(theme, theme.themeNameBase);
            break;
    }
    Object.keys(theme).forEach(function (key) {
        // пропускаем служебные ключи
        if (exports.serviceKeys.includes(key)) {
            return;
        }
        var token = theme[key];
        // в инкрементальном режиме пропускаем токены, чьи значения совпадают со значениями из themeBase
        if (incremental && themeBase && isDeepEqual(token, themeBase[key])) {
            return;
        }
        // если переменная — строка (например, имя темы)
        if ((0, tokenRecognition_1.isString)(token, key)) {
            variables += getVariableStatement(getDeclaration(key, prefix), "'".concat(CSS.escape(token), "'"));
            return;
        }
        // если переменная — цвет
        if ((0, tokenRecognition_1.isColor)(token)) {
            Object.keys(token).forEach(function (colorState) {
                var value = token[colorState];
                variables += getVariableStatement(getDeclaration(key, prefix), value, colorState !== 'normal' ? "--".concat(colorState) : '');
            });
            return;
        }
        // если переменная — это объект (группа значений)
        // например — шрифты
        if ((0, tokenRecognition_1.isGroupToken)(token)) {
            var groupTokenResult = (0, tokenProcessors_1.processGroupToken)({
                format: format,
                prefix: prefix,
                token: token,
                key: key,
                adaptiveMode: mode,
            });
            variables += groupTokenResult.variables;
            groupTokens += groupTokenResult.groupTokens;
            return;
        }
        if ((0, tokenRecognition_1.isAdaptiveFlatToken)(token)) {
            Object.keys(token).forEach(function (adaptivivityState) {
                var value = token[adaptivivityState];
                variables += getVariableStatement(getDeclaration(key, prefix), value, "--".concat((0, unCamelcasify_1.unCamelcasify)(adaptivivityState, classicCssType ? '_' : '-')));
            });
            return;
        }
        if ((0, tokenRecognition_1.isCustomMediaToken)(key)) {
            if (getCustomMediaDeclaration) {
                groupTokens += getCustomMediaDeclaration(key, token);
            }
            return;
        }
        // обычная переменная
        variables += getVariableStatement(getDeclaration(key, prefix), token);
    });
    result = variables;
    if (classicCssType && variables) {
        result = (0, common_tags_1.stripIndent)(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n\t\t", " {\n\t\t", "}\n\t\t"], ["\n\t\t", " {\n\t\t", "}\n\t\t"])), rootSelector, variables.split('\n').join('\n\t\t'));
    }
    if (isOnlyVariables(mode)) {
        return (0, common_tags_1.stripIndent)(result);
    }
    if (mode === 'onlyAdaptiveGroups') {
        return (0, common_tags_1.stripIndent)(groupTokens);
    }
    result += "\n\n".concat(groupTokens);
    return (0, common_tags_1.stripIndent)(result);
};
exports.compileStyles = compileStyles;
var templateObject_1;
