"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compileDocsJSON = exports.getTypeDocs = void 0;
var node_path_1 = __importDefault(require("node:path"));
var ts_morph_1 = require("ts-morph");
var capitalize_1 = require("../../helpers/capitalize");
function getTagDescription(tag) {
    return tag
        .getText()
        .map(function (part) {
        switch (part.kind) {
            case 'text':
                return {
                    type: 'text',
                    text: part.text,
                };
            case 'linkText': {
                var _a = part.text.split(' '), url = _a[0], urlText = _a[1];
                if (!url) {
                    throw new Error('[desc] Ожидаемый формат ссылки в JSDoc `{@link url urlText}` или `{@link url}`');
                }
                return {
                    url: url,
                    type: 'link',
                    text: urlText || url,
                };
            }
            case 'link':
            default:
                return null;
        }
    })
        .filter(function (i) { return i !== null; });
}
function getTagText(tag) {
    return tag
        .getText()
        .map(function (part) { return part.text; })
        .join(' ');
}
function resolveDeclaration(declaration) {
    if (ts_morph_1.Node.isExportSpecifier(declaration)) {
        // export { A as B } from 'path/to/module.ts'
        var declarations = declaration.getNameNode().getSymbol().getDeclarations();
        return resolveDeclarations(declarations);
    }
    return [declaration];
}
function resolveDeclarations(declarations) {
    return declarations.reduce(function (all, declaration) {
        return all.concat(resolveDeclaration(declaration));
    }, []);
}
function getExportedTypeDeclarations(file, typeName) {
    var exportSymbol = file.getExportSymbols().find(function (symbol) {
        return symbol.getName() === typeName;
    });
    var declarations = exportSymbol.getDeclarations();
    return resolveDeclarations(declarations);
}
function mapJsDocTagsToThemePropertyDoc(tags) {
    var doc = {
        tags: [],
        desc: [],
    };
    tags.forEach(function (tag) {
        var tagName = tag.getName();
        if (tagName === 'desc' || tagName === 'description') {
            doc.desc = getTagDescription(tag);
        }
        else if (tagName === 'tags') {
            var docTags = getTagText(tag);
            doc.tags = docTags.split(',').map(function (tag) { return tag.trim(); });
        }
        else if (tagName === 'tag') {
            var docTag = getTagText(tag);
            doc.tags.push(docTag);
        }
    });
    return doc;
}
function getTypeDocs(filePath, name) {
    var project = new ts_morph_1.Project({
        tsConfigFilePath: 'tsconfig.json',
        skipAddingFilesFromTsConfig: true,
    });
    var file = project.addSourceFileAtPath(filePath);
    var declarations = getExportedTypeDeclarations(file, name);
    return declarations.reduce(function (prevDocs, declaration) {
        var rawProperties = declaration.getType().getApparentProperties();
        var parsedProperties = rawProperties
            .reduce(function (acc, prop) {
            acc.push([prop.getName(), mapJsDocTagsToThemePropertyDoc(prop.getJsDocTags())]);
            return acc;
        }, [])
            .sort(function (_a, _b) {
            var a = _a[0];
            var b = _b[0];
            return a.localeCompare(b);
        });
        var docs = parsedProperties.reduce(function (acc, _a) {
            var key = _a[0], value = _a[1];
            acc[key] = value;
            return acc;
        }, {});
        return __assign(__assign({}, prevDocs), docs);
    }, {});
}
exports.getTypeDocs = getTypeDocs;
/**
 * Компилирует документацию для полей интерфейса темы и возвращает сериализованный JSON
 *
 * Собирает из jsDoc комментариев над полями интерфейса темы следующего следующие теги:
 * 	 - @desc/@description <desc> – описание поля
 * 	 - @tag <tag> – добавить тег (можно использовать несколько раз)
 * 	 - @tags <tag>, <tag>, ... – задать список тегов, разделённых запятой
 *
 * По итогу компиляции формирует JSON вида:
 * 	 {
 * 	   "<property>": {
 * 	   	 "desc": "<desc>",
 * 	     "tags": ["<tag>", "<tag>", ...]
 * 	   },
 * 	   ...
 * 	 }
 *
 * Умеет работать с выражениями вида:
 * 	 - export interface MyTheme { ... }
 * 	 - interface BaseTheme1 { ... }
 * 	   interface BaseTheme2 { ... }
 * 	 	 export interface MyTheme extends BaseTheme1, BaseTheme2 { ... }
 * 	 - import { AnotherBaseTheme } from 'path/to/baseTheme.ts'
 *   	 import { MyTheme, BaseTheme } from 'path/to/myTheme.ts'
 * 	   export interface MyDarkTheme extends MyTheme, BaseTheme, AnotherBaseTheme
 * 	 - export { BaseTheme as MyTheme } from 'path/to/baseTheme.ts'
 */
function compileDocsJSON(theme) {
    var themeFilePath = node_path_1.default.resolve("src/interfaces/themes/".concat(theme.themeName, "/index.ts"));
    var themeInterfaceName = "Theme".concat((0, capitalize_1.capitalize)(theme.themeName));
    var docs = getTypeDocs(themeFilePath, themeInterfaceName);
    return JSON.stringify(docs, null, '  ');
}
exports.compileDocsJSON = compileDocsJSON;
