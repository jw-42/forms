"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compileStructJSON = void 0;
var color_1 = __importDefault(require("color"));
var convertSnakeToCamel_1 = require("../../helpers/convertSnakeToCamel");
var groups = [
    'fontFamily',
    'fontWeight',
    'colorsScheme',
    'size',
    'opacity',
    'zIndex',
    'elevation',
    'gradient',
    'animation',
    'color',
    'font',
    'theme',
    'blur',
    // Todo: Раскомментить в VKUI Tokens 5.0
    // 'spacing',
    'other',
];
function parseRawToken(rawToken) {
    var percentMatch = rawToken.match(/\d+$/);
    var step = percentMatch && percentMatch.length > 0 ? parseFloat(percentMatch[0]) / 100 : undefined;
    rawToken = rawToken.replace(/^,\s/g, '').replace(/\d+$/g, '').trim();
    if (rawToken.startsWith('var(')) {
        var varNameRaw = /^var\(([\w\-_]+)/.exec(rawToken);
        if (varNameRaw) {
            var varName = varNameRaw[1];
            var varValue = rawToken.slice(varNameRaw[0].length, -1).trim().slice(1).trim();
            return {
                step: step,
                color: varValue,
                token: (0, convertSnakeToCamel_1.convertSnakeToCamel)(varName),
                alpha: new color_1.default(varValue).alpha(),
            };
        }
    }
    return {
        color: rawToken,
        step: step,
        alpha: new color_1.default(rawToken).alpha(),
    };
}
function compileStructGradients(cssGradients) {
    var structGradients = {};
    var keys = Object.keys(cssGradients);
    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        var rawPoints = cssGradients[key].split('%').slice(0, -1);
        structGradients[key] = rawPoints.map(parseRawToken).map(function (structToken, index, array) {
            var _a;
            if (!structToken.token) {
                return {
                    step: structToken.step,
                    color: structToken.color,
                    // Только последнее значение распространяется на все точки
                    // (как в градиенте, сгенерированном по 1 переменной)
                    // Тут могут всплыть ошибки, так что заранее сорри
                    token: (_a = structToken.token) !== null && _a !== void 0 ? _a : array[array.length - 1].token,
                    alpha: structToken.alpha,
                };
            }
            return structToken;
        });
    }
    return structGradients;
}
/**
 * Компилирует структурируемый json с темой
 */
var compileStructJSON = function (theme) {
    var structTheme = {};
    Object.keys(theme).forEach(function (key) {
        var group = groups.find(function (predicate) { return key.startsWith(predicate); }) || 'other';
        if (!structTheme[group]) {
            structTheme[group] = {};
        }
        structTheme[group][key] = theme[key];
    });
    if (structTheme['gradient']) {
        structTheme['gradient'] = compileStructGradients(structTheme['gradient']);
    }
    return JSON.stringify(structTheme, null, '\t');
};
exports.compileStructJSON = compileStructJSON;
